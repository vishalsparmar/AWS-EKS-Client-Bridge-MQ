curl -sSL -o argocd-windows-amd64.exe https://github.com/argoproj/argo-cd/releases/latest/download/argocd-windows-amd64.exe

argocd app list -o json | jq '.[] | {name: .metadata.name, namespace: .spec.destination.namespace}'

argocd app list -o json | jq '.[] | {name: .metadata.name, namespace: .spec.destination.namespace}'


bash
echo -e "APP_NAME\tNAMESPACE\tVERSION\tSYNC_STATUS\tHEALTH_STATUS" && argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("prod")) | "\(.metadata.name)\t\(.spec.destination.namespace)\t\(.spec.source.targetRevision)\t\(.status.sync.status)\t\(.status.health.status)"' | column -t
Method 4: Clean Formatted Output



1. Using ApplicationSet for Multiple Versions

yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: myapp-versions
  namespace: argocd
spec:
  generators:
  - list:
      elements:
      - version: v1.0.0
        replicas: 3
      - version: v1.1.0
        replicas: 2
      - version: v2.0.0
        replicas: 1
  template:
    metadata:
      name: 'myapp-{{version}}'
    spec:
      project: default
      source:
        repoURL: 'https://github.com/myorg/myapp.git'
        targetRevision: '{{version}}'
        path: k8s/
      destination:
        server: 'https://kubernetes.default.svc'
        namespace: 'myapp-{{version}}'
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
2. Individual Application Resources

yaml
# Application for v1.0.0
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp-v1.0.0
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/myorg/myapp.git
    targetRevision: v1.0.0
    path: k8s/
  destination:
    server: https://kubernetes.default.svc
    namespace: myapp-v1.0.0
  sync
I alredyhave apps deployed , I need around ui dashboard to get list of all my app version per environment . doesargocd provide this
Yes, ArgoCD provides this capability through its web UI. Here's what you get out of the box and how to use it:

ArgoCD Built-in Application Dashboard

1. Main Applications View

Lists all deployed applications
Shows:

Application name
Project
Cluster
Namespace
Sync Status
Health Status
Repository URL
Revision/Version
2. Application Details View

Click on any application to see:

Source Revision - The exact git commit/tag/version
Sync Status with timestamp
Health Status
Resource tree
Source section showing:

Repository URL
Target Revision (your version)
Path
3. Filtering and Grouping

By Project:

bash
# In UI: Use project filter dropdown
# Or via CLI:
argocd app list --project <project-name>
By Label:

yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: myapp-production
  labels:
    environment: production
    version: v1.2.3
    team: backend
Then filter by labels in UI or:

bash
argocd app list -l environment=production
4. Enhanced Version Tracking with Labels

Add version information to your applications:

yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: frontend-production
  labels:
    app: frontend
    environment: production
    version: "1.5.2"  # Explicit version label
    team: web-ui
spec:
  source:
    repoURL: https://github.com/myorg/apps.git
    targetRevision: v1.5.2  # Git tag/version
    path: frontend/
5. Creating a Custom Dashboard View

Using ApplicationSets for Consistent Labeling:

yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: environment-apps
spec:
  generators:
  - git:
      repoURL: https://github.com/myorg/environments.git
      revision: HEAD
      directories:
      - path: "*/apps/*"
  template:
    metadata:
      name: '{{path.basename}}'
      labels:
        environment: '{{path.basename}}'
        cluster: '{{cluster}}'
    spec:
      project: '{{metadata.labels.environment}}'
      source:
        repoURL: https://github.com/myorg/apps.git
        targetRevision: '{{version}}'
        path: '{{app_path}}'
6. ArgoCD CLI for Version Reports

bash
# Get all apps with versions
argocd app list -o wide

# Get specific app version
argocd app get <app-name> -o json | jq '.spec.source.targetRevision'

# Generate version report per environment
argocd app list -l environment=production -o json | jq '.[] | {name: .metadata.name, version: .spec.source.targetRevision}'
7. Custom Dashboard Options

Option 1: ArgoCD UI with Bookmarks

Bookmark filtered views for each environment
Use the search/filter functionality
Option 2: Export to External Dashboard

bash
# Export data for custom dashboard
argocd app list -o json > apps.json

# Process with jq to create version report
argocd app list -o json | jq '
  [.[] | {
    app: .metadata.name,
    environment: (.metadata.labels.environment // "default"),
    version: .spec.source.targetRevision,
    syncStatus: .status.sync.status,
    healthStatus: .status.health.status
  }] | group_by(.environment)' > version-dashboard.json
8. Example View in ArgoCD UI

Your dashboard would show:

text
APPLICATION           | ENVIRONMENT | VERSION  | SYNC STATUS | HEALTH
---------------------|-------------|----------|-------------|--------
frontend-production  | production  | v1.5.2   | Synced      | Healthy
backend-staging      | staging     | v1.5.3   | OutOfSync   | Healthy
api-production       | production  | v2.0.1   | Synced      | Healthy
9. Best Practices

Use consistent labeling across all applications
Use semantic versioning in git tags
Leverage projects to separate environments
Use ApplicationSets for consistent metadata
The ArgoCD UI provides this functionality natively - you just need to ensure your applications are properly labeled and organized. The main Applications view already shows the version (target revision) for each app, and you can filter by project or labels to see environment-specific views.
in ui can I create this per cluster and their apps
Yes! ArgoCD provides excellent cluster-based views and organization. Here's how to create a dashboard view per cluster with their applications:

1. Cluster-Based Organization in ArgoCD UI

Default Cluster View

ArgoCD automatically groups applications by cluster in the UI
The main Applications view shows "Cluster" column
You can filter by cluster using the search/filter box
Filter by Cluster in UI:

text
cluster:https://kubernetes.default.svc
or

text
cluster:production-cluster
2. Setting Up Cluster-Specific Views

Method 1: Using Projects to Organize by Cluster

yaml
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: production-cluster
  namespace: argocd
spec:
  description: Production Cluster Applications
  destinations:
  - namespace: '*'
    server: 'https://production-cluster.example.com'
  sourceRepos:
  - '*'
---
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: staging-cluster
  namespace: argocd
spec:
  description: Staging Cluster Applications
  destinations:
  - namespace: '*'
    server: 'https://staging-cluster.example.com'
  sourceRepos:
  - '*'
Method 2: Application with Cluster Labels

yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: frontend-production
  labels:
    cluster: production
    environment: production
    app: frontend
    version: v1.5.2
spec:
  project: production-cluster
  source:
    repoURL: https://github.com/myorg/apps.git
    targetRevision: v1.5.2
    path: frontend/
  destination:
    server: https://production-cluster.example.com
    namespace: frontend
3. Creating Cluster-Specific ApplicationSets

yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: cluster-apps
  namespace: argocd
spec:
  generators:
  - clusters: 
      selector:
        matchLabels:
          argocd.argoproj.io/secret-type: cluster
  template:
    metadata:
      name: '{{name}}-apps'
      labels:
        cluster: '{{name}}'
        managed-by: applicationset
    spec:
      project: 'default'
      source:
        repoURL: https://github.com/myorg/cluster-configs.git
        targetRevision: HEAD
        path: 'clusters/{{name}}/'
      destination:
        server: '{{server}}'
        namespace: argocd
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
4. Multiple Cluster Setup with Applications

Register Clusters First:

bash
# Add external clusters
argocd cluster add production-cluster --name production
argocd cluster add staging-cluster --name staging
Applications for Different Clusters:

yaml
# Production Cluster App
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: api-production
  labels:
    cluster: production
    environment: production
    app: api
spec:
  project: production-cluster
  source:
    repoURL: https://github.com/myorg/apps.git
    targetRevision: v2.1.0
    path: api/
  destination:
    server: https://production-cluster.example.com
    namespace: api

---
# Staging Cluster App
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: api-staging
  labels:
    cluster: staging
    environment: staging
    app: api
spec:
  project: staging-cluster
  source:
    repoURL: https://github.com/myorg/apps.git
    targetRevision: v2.2.0-beta
    path: api/
  destination:
    server: https://staging-cluster.example.com
    namespace: api
5. UI Views and Filtering

Cluster Filter in ArgoCD UI:

Use the search box with cluster-specific queries:
text
cluster:production
text
cluster:staging
Multiple Filter Combinations:

text
cluster:production,environment:production
text
cluster:staging,app:frontend
6. Creating Bookmarked Views

Bookmark Production Cluster View:

Go to Applications view
Apply filter: cluster:production
Click "Bookmark" icon to save this view
Name it "Production Cluster Apps"
Bookmark Staging Cluster View:

Filter: cluster:staging
Save as "Staging Cluster Apps"
7. CLI Commands for Cluster Reports

bash
# List all apps in production cluster
argocd app list --grpc-web | grep "production-cluster"

# Get cluster-specific app versions
argocd app list -o json | jq '
  [.[] | select(.spec.destination.server == "https://production-cluster.example.com") | {
    app: .metadata.name,
    version: .spec.source.targetRevision,
    syncStatus: .status.sync.status,
    health: .status.health.status
  }]'

# Compare versions across clusters
argocd app list -o json | jq '
  reduce .[] as $app ({};
    .[$app.spec.destination.server] += [{
      app: $app.metadata.name,
      version: $app.spec.source.targetRevision
    }]
  )'
8. Advanced: ApplicationSet for Multi-Cluster Deployment

yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: multi-cluster-apps
spec:
  generators:
  - matrix:
      generators:
      - clusters:
          selector:
            matchLabels:
              environment: production
      - git:
          repoURL: https://github.com/myorg/apps.git
          revision: HEAD
          directories:
          - path: "apps/*"
  template:
    metadata:
      name: '{{path.basename}}-{{name}}'
      labels:
        cluster: '{{name}}'
        app: '{{path.basename}}'
        environment: '{{metadata.labels.environment}}'
    spec:
      project: '{{name}}'
      source:
        repoURL: https://github.com/myorg/apps.git
        targetRevision: HEAD
        path: '{{path.path}}'
      destination:
        server: '{{server}}'
        namespace: '{{path.basename}}'
9. Example Dashboard View

In ArgoCD UI, you'll see:

Production Cluster View:

text
APPLICATION           | CLUSTER     | VERSION  | STATUS
---------------------|-------------|----------|--------
frontend-production  | production  | v1.5.2   | Healthy
api-production       | production  | v2.1.0   | Healthy
db-production        | production  | v1.0.1   | Healthy
Staging Cluster View:

text
APPLICATION           | CLUSTER     | VERSION  | STATUS
---------------------|-------------|----------|--------
frontend-staging     | staging     | v1.6.0   | Healthy  
api-staging          | staging     | v2.2.0   | Healthy
The ArgoCD UI naturally supports this cluster-based organization. You just need to:

Register your clusters with ArgoCD
Organize applications using proper cluster destinations
Use labels and projects for better filtering
Create bookmarks for quick access to cluster-specific views
where is book mark icon
In ArgoCD UI, the bookmark functionality is located in the Applications view. Here's how to find and use it:

Location of Bookmark Icon

Steps to Find Bookmark Icon:

Navigate to Applications:

Go to your ArgoCD UI (usually https://argocd.your-domain.com)
Click on "Applications" in the left sidebar
Look for the Bookmark Icon:

In the Applications view, look at the top right corner of the applications list
You should see a "star" icon (‚òÜ) or "bookmark" icon
Exact Location:

Top-right corner of the applications table
Next to the filter/search bar
Usually between the refresh button and settings/view options
How to Create a Bookmarked View

Step-by-Step:

Apply Your Filters:

Use the search/filter box to set up your view
Example: cluster:production or environment:staging
Click the Bookmark Icon:

After applying filters, click the star/bookmark icon
It will open a "Save view" dialog
Save the View:

text
Name: Production Cluster Apps
Description: All applications in production cluster
Access Bookmarked Views:

Click the bookmark icon again to see your saved views
Or look for a "Saved views" dropdown near the filter bar
If You Can't Find the Bookmark Icon

Possible Reasons:

ArgoCD Version:

Bookmark feature was added in v2.4+
Check your ArgoCD version: argocd version
UI Location Variations:

Some versions have it in the filter bar
Look for: ‚òÜ, ‚≠ê, or "Save view" text
Permissions:

Ensure you have appropriate permissions to save views
Alternative Locations to Check:

Three-dots menu (‚ãØ) in applications view
Settings cog icon near the filter
View options dropdown
Manual Alternative

If you can't find bookmarks, you can:

Use URL Bookmarks:

Apply your filters
Bookmark the URL in your browser
Example URL with filters: https://argocd.example.com/applications?filter=cluster%3Aproduction
Use Projects for Organization:

yaml
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: production-view
spec:
  destinations:
  - server: 'https://production-cluster.example.com'
Screenshot Guidance

Look for this visual pattern in Applications view:

text
[Search Box] üìã ‚òÜ ‚öôÔ∏è ‚ü≥
Where:

üìã = Copy/Paste
‚òÜ = Bookmark/Save view
‚öôÔ∏è = Settings
‚ü≥ = Refresh
Verify ArgoCD Version

bash
# Check if bookmarks are available in your version
argocd version

# Look for:
# argocd-server: v2.4.0+  # Bookmarks available
# argocd-server: v2.3.x   # May not have bookmarks
If you're on an older version without bookmarks, consider upgrading or use the URL/bookmark alternative method. The cluster-based filtering will still work - you'll just need to manually apply the filters each time or use browser bookmarks with the filter URLs.
I need list of append their version deployed and have on ly one env but ned argocd ui simple list view
Here's how to get a simple list view of all applications with their versions in ArgoCD UI:

Simple Applications List View

1. Navigate to Applications View

Go to ArgoCD UI
Click on "Applications" in the left sidebar
This shows the default list view
2. Default Columns Show:

text
APPLICATION | PROJECT | CLUSTER | NAMESPACE | SYNC STATUS | HEALTH STATUS
The version is in the tooltip/details
3. To See Version Clearly:

Option A: View Application Details

Click on any application name
In the application details page, look for:

"SOURCE" section
"TARGET REVISION" - This is your deployed version
Option B: Use Table Customization

In Applications view, click the ‚öôÔ∏è Settings icon (column selector)
Enable additional columns like:

"REPO" - Shows repository
"REVISION" - Shows the version/commit
4. Simple CLI Command for Quick List

bash
argocd app list -o wide
Shows:

text
NAME                  CLUSTER                         NAMESPACE  PROJECT  STATUS  HEALTH   SYNCPOLICY  REPO                                             PATH  TARGET
frontend-production   https://kubernetes.default.svc  production default  Synced Healthy  Auto        https://github.com/myorg/apps.git frontend/  v1.5.2
api-staging          https://kubernetes.default.svc  staging    default  Synced Healthy  Auto        https://github.com/myorg/apps.git api/       v2.1.0
5. Export to Simple Format

bash
# Simple text list
argocd app list -o name | while read app; do
  version=$(argocd app get $app -o json | jq -r '.spec.source.targetRevision')
  echo "$app: $version"
done
Output:

text
frontend-production: v1.5.2
api-staging: v2.1.0
db-production: v1.0.1
6. JSON Export for Processing

bash
argocd app list -o json | jq -r '.[] | "\(.metadata.name): \(.spec.source.targetRevision)"'
7. If You Want a Custom Simple UI View

Create a simple script to display:

bash
#!/bin/bash
echo "APPLICATION VERSION REPORT"
echo "=========================="
argocd app list -o json | jq -r '.[] | "\(.metadata.name)|\(.spec.source.targetRevision)|\(.status.sync.status)|\(.status.health.status)"' | column -t -s "|"
Output:

text
APPLICATION           VERSION  SYNC_STATUS  HEALTH_STATUS
frontend-production   v1.5.2   Synced       Healthy
api-staging          v2.1.0   Synced       Healthy
db-production        v1.0.1   OutOfSync    Healthy
8. Quick Browser View

Just use the main Applications page
The information is there, you might need to:

Scroll horizontally if many columns
Click into each app to see exact version
Or use the CLI for a cleaner view
9. One-Command Simple Report

bash
argocd app list -o json | jq '
  ["APPLICATION", "VERSION", "STATUS", "HEALTH"],
  (.[] | [.metadata.name, .spec.source.targetRevision, .status.sync.status, .status.health.status])
  | @tsv' -r
The simplest approach is just using the main Applications view in ArgoCD UI and optionally customizing the columns to show exactly what you need. For the cleanest "app:version" list, the CLI commands work best.
I want this automated and I am using aws
Here are automated solutions for AWS to get ArgoCD application versions:

Option 1: AWS Lambda + EventBridge (Recommended)

Lambda Function (Python)

python
import json
import subprocess
import os

def lambda_handler(event, context):
    try:
        # Get ArgoCD credentials from environment variables
        argocd_server = os.environ['ARGOCD_SERVER']
        argocd_username = os.environ['ARGOCD_USERNAME']
        argocd_password = os.environ['ARGOCD_PASSWORD']
        
        # Login to ArgoCD
        login_cmd = f"argocd login {argocd_server} --username {argocd_username} --password {argocd_password} --grpc-web"
        subprocess.run(login_cmd, shell=True, check=True)
        
        # Get application list
        result = subprocess.run(
            "argocd app list -o json",
            shell=True,
            capture_output=True,
            text=True,
            check=True
        )
        
        apps_data = json.loads(result.stdout)
        
        # Format the output
        app_versions = []
        for app in apps_data:
            app_versions.append({
                'application': app['metadata']['name'],
                'version': app['spec']['source'].get('targetRevision', 'N/A'),
                'sync_status': app['status']['sync']['status'],
                'health_status': app['status']['health']['status'],
                'cluster': app['spec']['destination']['server'],
                'namespace': app['spec']['destination']['namespace'],
                'timestamp': event.get('time', '')
            })
        
        # Send to S3
        if app_versions:
            upload_to_s3(app_versions)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': f'Successfully processed {len(app_versions)} applications',
                'applications': app_versions
            })
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def upload_to_s3(app_versions):
    import boto3
    from datetime import datetime
    
    s3 = boto3.client('s3')
    bucket_name = os.environ['S3_BUCKET']
    
    # Create JSON file
    timestamp = datetime.utcnow().strftime('%Y-%m-%d-%H-%M-%S')
    filename = f"argocd-versions/{timestamp}.json"
    
    s3.put_object(
        Bucket=bucket_name,
        Key=filename,
        Body=json.dumps(app_versions, indent=2),
        ContentType='application/json'
    )
    
    # Also create a CSV for easy viewing
    csv_data = "Application,Version,Sync Status,Health Status,Cluster,Namespace,Timestamp\n"
    for app in app_versions:
        csv_data += f"{app['application']},{app['version']},{app['sync_status']},{app['health_status']},{app['cluster']},{app['namespace']},{app['timestamp']}\n"
    
    s3.put_object(
        Bucket=bucket_name,
        Key=f"argocd-versions/latest.csv",
        Body=csv_data,
        ContentType='text/csv'
    )
CloudFormation/Terraform for Lambda

yaml
# cloudformation-template.yaml
Resources:
  ArgoCDVersionLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: argocd-version-reporter
      Runtime: python3.9
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          # Paste the Python code above
      Timeout: 300
      Environment:
        Variables:
          ARGOCD_SERVER: "your-argocd-server.com"
          ARGOCD_USERNAME: "admin"
          ARGOCD_PASSWORD: "your-password"
          S3_BUCKET: "your-bucket-name"
      Role: !GetAtt LambdaExecutionRole.Arn

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource: "arn:aws:s3:::your-bucket-name/*"

  ScheduledRule:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: "rate(1 hour)"  # Run every hour
      Targets:
        - Arn: !GetAtt ArgoCDVersionLambda.Arn
          Id: "ArgoCDVersionTarget"
Option 2: ECS Fargate Scheduled Task

Dockerfile

dockerfile
FROM python:3.9-alpine

# Install ArgoCD CLI
RUN wget -q -O /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
RUN chmod +x /usr/local/bin/argocd

# Install AWS CLI
RUN pip install awscli boto3

COPY script.py /script.py
CMD ["python", "/script.py"]
Python Script

python
#!/usr/bin/env python3
import subprocess
import json
import boto3
from datetime import datetime
import os

def main():
    # ArgoCD login
    server = os.environ['ARGOCD_SERVER']
    username = os.environ['ARGOCD_USERNAME']
    password = os.environ['ARGOCD_PASSWORD']
    
    subprocess.run([
        'argocd', 'login', server,
        '--username', username,
        '--password', password,
        '--grpc-web'
    ], check=True)
    
    # Get applications
    result = subprocess.run([
        'argocd', 'app', 'list', '-o', 'json'
    ], capture_output=True, text=True, check=True)
    
    apps = json.loads(result.stdout)
    
    # Prepare data
    version_data = []
    for app in apps:
        version_data.append({
            'application': app['metadata']['name'],
            'version': app['spec']['source'].get('targetRevision', 'N/A'),
            'sync_status': app['status']['sync']['status'],
            'health_status': app['status']['health']['status'],
            'timestamp': datetime.utcnow().isoformat()
        })
    
    # Upload to S3
    s3 = boto3.client('s3')
    bucket = os.environ['S3_BUCKET']
    
    # JSON output
    s3.put_object(
        Bucket=bucket,
        Key=f"argocd-versions/{datetime.utcnow().strftime('%Y/%m/%d/%H-%M-%S')}.json",
        Body=json.dumps(version_data, indent=2)
    )
    
    # HTML dashboard
    html_content = generate_html_dashboard(version_data)
    s3.put_object(
        Bucket=bucket,
        Key="dashboard.html",
        Body=html_content,
        ContentType='text/html'
    )
    
    print(f"Processed {len(version_data)} applications")

def generate_html_dashboard(apps):
    html = """
    <html>
    <head>
        <title>ArgoCD Application Versions</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; }
            .healthy { background-color: #d4edda; }
            .synced { color: green; }
        </style>
    </head>
    <body>
        <h1>ArgoCD Application Versions</h1>
        <p>Last updated: """ + datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC') + """</p>
        <table>
            <tr>
                <th>Application</th>
                <th>Version</th>
                <th>Sync Status</th>
                <th>Health Status</th>
            </tr>
    """
    
    for app in apps:
        sync_class = "synced" if app['sync_status'] == 'Synced' else ""
        health_class = "healthy" if app['health_status'] == 'Healthy' else ""
        html += f"""
            <tr>
                <td>{app['application']}</td>
                <td>{app['version']}</td>
                <td class="{sync_class}">{app['sync_status']}</td>
                <td class="{health_class}">{app['health_status']}</td>
            </tr>
        """
    
    html += """
        </table>
    </body>
    </html>
    """
    return html

if __name__ == "__main__":
    main()
Option 3: Simple AWS CodeBuild Solution

buildspec.yaml

yaml
version: 0.2
phases:
  install:
    commands:
      - wget -q -O argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
      - chmod +x argocd
      - mv argocd /usr/local/bin/
  build:
    commands:
      - argocd login $ARGOCD_SERVER --username $ARGOCD_USERNAME --password $ARGOCD_PASSWORD --grpc-web
      - argocd app list -o json > apps.json
      - |
        echo "APPLICATION,VERSION,SYNC_STATUS,HEALTH_STATUS" > versions.csv
        jq -r '.[] | [.metadata.name, .spec.source.targetRevision, .status.sync.status, .status.health.status] | @csv' apps.json >> versions.csv
  post_build:
    commands:
      - aws s3 cp versions.csv s3://$S3_BUCKET/argocd-versions/latest.csv
      - aws s3 cp apps.json s3://$S3_BUCKET/argocd-versions/$(date +%Y-%m-%d-%H-%M-%S).json
Deployment Steps:

Choose your preferred option (Lambda recommended for simplicity)
Create S3 bucket for storing reports
Store ArgoCD credentials in AWS Secrets Manager or environment variables
Deploy the automation
Set up EventBridge schedule (e.g., run every hour)
Quick Start with Lambda:

bash
# Package and deploy Lambda
zip lambda-function.zip lambda-handler.py

aws lambda create-function \
    --function-name argocd-version-reporter \
    --runtime python3.9 \
    --role arn:aws:iam::123456789012:role/lambda-execution-role \
    --handler lambda-handler.lambda_handler \
    --environment Variables={ARGOCD_SERVER=your-server,ARGOCD_USERNAME=admin,ARGOCD_PASSWORD=your-password,S3_BUCKET=your-bucket} \
    --zip-file fileb://lambda-function.zip
The Lambda solution is the most cost-effective and easiest to maintain. It will automatically generate both JSON and CSV files in S3 that you can access anytime.
how to setup argocd local for cli usage
Here's how to set up ArgoCD locally for CLI usage:

Method 1: Install ArgoCD CLI Only (Lightweight)

Download and Install ArgoCD CLI

macOS:

bash
# Using Homebrew
brew install argocd

# Or download directly
curl -sSL -o argocd-darwin-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-darwin-amd64
sudo install -m 555 argocd-darwin-amd64 /usr/local/bin/argocd
rm argocd-darwin-amd64
Linux:

bash
# Download binary
curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
rm argocd-linux-amd64
Windows:

powershell
# Using Chocolatey
choco install argocd

# Or download manually
# Download from: https://github.com/argoproj/argo-cd/releases/latest/download/argocd-windows-amd64.exe
# Rename to argocd.exe and add to PATH
Verify Installation:

bash
argocd version --client
Method 2: Run Full ArgoCD Locally with Docker

Using Docker Compose (Recommended)

Create docker-compose.yml:
yaml
version: '3'
services:
  argocd:
    image: argoproj/argocd:latest
    ports:
      - "8080:8080"
      - "443:443"
    environment:
      - ARGOCD_API_SERVER=0.0.0.0:8080
      - ARGOCD_UI_URL=https://localhost:8080
    volumes:
      - argocd-data:/app
    command: [
      "argocd-server",
      "--insecure",
      "--staticassets",
      "/shared/app"
    ]

  redis:
    image: redis:7-alpine

volumes:
  argocd-data:
Start ArgoCD:
bash
docker-compose up -d
Using minikube or kind

With minikube:

bash
# Start minikube
minikube start

# Install ArgoCD
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Wait for pods to be ready
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

# Port forward to access locally
kubectl port-forward svc/argocd-server -n argocd 8080:
I have argocd cli installed local , how to connect to my eks argocd whee its installed lready
Here's how to connect your local ArgoCD CLI to your existing EKS ArgoCD installation:

Method 1: Port Forwarding (Most Common)

Step 1: Get ArgoCD Server Service

bash
# List services in argocd namespace
kubectl get svc -n argocd

# Look for argocd-server service
kubectl port-forward -n argocd svc/argocd-server 8080:443
Step 2: Login via CLI

bash
# Login to local port-forward
argocd login localhost:8080

# If you get SSL errors, use --insecure flag
argocd login localhost:8080 --insecure
Step 3: Get Initial Password

bash
# Get the initial admin password
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d

# Or if you've changed the password, use your current password
Method 2: Using LoadBalancer/ELB

Step 1: Find ArgoCD External URL

bash
# Check if argocd-server has an external load balancer
kubectl get svc argocd-server -n argocd

# Look for EXTERNAL-IP or use AWS LoadBalancer hostname
Step 2: Login via External URL

bash
# Login using the external URL
argocd login <your-argocd-elb-url>

# Example:
argocd login a1b2c3d4e5f6g7h8.us-east-1.elb.amazonaws.com
Method 3: Using Ingress/Route53

If you have ingress configured:

bash
# Login via your custom domain
argocd login argocd.your-company.com
Complete Setup Example:

1. Port Forward and Login:

bash
# Terminal 1 - Keep this running
kubectl port-forward -n argocd svc/argocd-server 8080:443

# Terminal 2 - Login
argocd login localhost:8080 --insecure --username admin

# You'll be prompted for password
2. Get Password:

bash
# Get the admin password
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo

# Copy the password and paste when prompted
3. Verify Connection:

bash
# List applications to verify
argocd app list

# Or get cluster info
argocd cluster list
Method 4: Configure Context (Persistent)

Create a context for easy switching:

bash
# Add your EKS cluster to argocd contexts
argocd context add my-eks-argocd \
  --server localhost:8080 \
  --insecure \
  --username admin

# Switch to this context
argocd context my-eks-argocd
Troubleshooting Common Issues:

SSL Certificate Issues:

bash
# Use --insecure flag to skip TLS verification
argocd login localhost:8080 --insecure

# Or use --grpc-web flag for web-based transport
argocd login localhost:8080 --grpc-web --insecure
Password Reset (if needed):

bash
# If you lost the password, reset it
kubectl -n argocd patch secret argocd-secret \
  -p '{"stringData": {"admin.password": "<new-password>", "admin.passwordMtime": "'$(date +%FT%T%Z)'"}}'
Network Connectivity:

bash
# Verify you can access the Kubernetes cluster
kubectl cluster-info

# Update kubeconfig if needed
aws eks update-kubeconfig --region <region> --name <cluster-name>
Quick One-Liner Setup:

bash
# Complete setup in one command (run in separate terminal)
(kubectl port-forward -n argocd svc/argocd-server 8080:443 &) && \
sleep 5 && \
argocd login localhost:8080 --insecure --username admin --password $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
Verify Everything Works:

bash
# Test the connection
argocd app list

# Get version info
argocd version

# List clusters
argocd cluster list
Persistent Setup Script:

Create a script connect-argocd.sh:

bash
#!/bin/bash
echo "Connecting to EKS ArgoCD..."

# Start port-forwarding in background
kubectl port-forward -n argocd svc/argocd-server 8080:443 &

# Wait for port-forward to establish
sleep 5

# Get password and login
PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
argocd login localhost:8080 --insecure --username admin --password $PASSWORD

echo "Connected! ArgoCD CLI is now ready to use."
echo "Run 'argocd app list' to see your applications."
The port-forwarding method is the most reliable for initial setup. Once connected, you can manage all your EKS ArgoCD applications from your local CLI!
ok am in now show me 1 cmd to get list of apps with version and sync status
Here's the single command to get a clean list of apps with version and sync status:

Single Command for App List with Version & Status

bash
argocd app list -o wide
Sample Output:

text
NAME                  CLUSTER                         NAMESPACE  PROJECT  STATUS    HEALTH   SYNCPOLICY  CONDITIONS  REPO                                             PATH        TARGET
frontend-production   https://kubernetes.default.svc  production default  Synced    Healthy  Auto        <none>      https://github.com/myorg/apps.git  frontend/   v1.5.2
api-staging          https://kubernetes.default.svc  staging    default  OutOfSync Healthy  Auto        <none>      https://github.com/myorg/apps.git  api/         v2.1.0
db-production        https://kubernetes.default.svc  production default  Synced    Healthy  Auto        <none>      https://github.com/myorg/apps.git  database/   v1.0.1
Alternative Cleaner Formats

Custom Columns Only:

bash
argocd app list -o json | jq -r '.[] | "\(.metadata.name)|\(.spec.source.targetRevision)|\(.status.sync.status)|\(.status.health.status)"' | column -t -s "|"
Output:

text
frontend-production  v1.5.2  Synced     Healthy
api-staging         v2.1.0  OutOfSync  Healthy
db-production       v1.0.1  Synced     Healthy
Even Simpler:

bash
argocd app list -o json | jq -r '.[] | "\(.metadata.name) - \(.spec.source.targetRevision) - \(.status.sync.status)"'
Output:

text
frontend-production - v1.5.2 - Synced
api-staging - v2.1.0 - OutOfSync
db-production - v1.0.1 - Synced
One-liner with Headers:

bash
argocd app list -o json | jq -r '["APP", "VERSION", "SYNC", "HEALTH"], (.[] | [.metadata.name, .spec.source.targetRevision, .status.sync.status, .status.health.status]) | @tsv' | column -t
Output:

text
APP                VERSION  SYNC      HEALTH
frontend-production v1.5.2   Synced    Healthy
api-staging        v2.1.0   OutOfSync Healthy
db-production      v1.0.1   Synced    Healthy
The simplest is argocd app list -o wide - it shows all the information you need in a clean table format!
I need filter on namespace reg ex
Here are the ways to filter apps by namespace using regex patterns with ArgoCD CLI:

Method 1: Using jq with Regex (Most Flexible)

Basic Namespace Regex Filter:

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("prod.*")) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
Common Regex Patterns:

Starts with "prod":

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("^prod")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Ends with "-prod":

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("-prod$")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Contains "staging":

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("staging")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Multiple patterns (prod OR staging):

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("prod|staging")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Exclude patterns (NOT prod):

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("prod") | not) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Method 2: Create Reusable Function

Add this to your .bashrc or .zshrc:

bash
argocd-apps-by-ns() {
    local pattern="$1"
    argocd app list -o json | jq -r --arg pattern "$pattern" '.[] | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)|\(.status.health.status)"' | column -t -s "|"
}
Usage:

bash
# Use the function
argocd-apps-by-ns "^prod"
argocd-apps-by-ns "staging"
argocd-apps-by-ns "prod|staging"
Method 3: Advanced Filter with Headers

bash
argocd app list -o json | jq -r --arg pattern "prod" '["APP", "NAMESPACE", "VERSION", "SYNC", "HEALTH"], (.[] | select(.spec.destination.namespace | test($pattern)) | [.metadata.name, .spec.destination.namespace, .spec.source.targetRevision, .status.sync.status, .status.health.status]) | @tsv' | column -t
Method 4: Specific Regex Examples

Namespace starts with "app-":

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("^app-")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Namespace ends with "-service":

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("-service$")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Namespace matches exact pattern:

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace == "production") | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Complex pattern (starts with "team-" and ends with "-prod"):

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("^team-.*-prod$")) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"'
Method 5: One-liner with Custom Output

bash
# Clean formatted output with headers
argocd app list -o json | jq -r '["APP", "NAMESPACE", "VERSION", "SYNC", "HEALTH"], (.[] | select(.spec.destination.namespace | test("prod")) | [.metadata.name, .spec.destination.namespace, .spec.source.targetRevision, .status.sync.status, .status.health.status]) | @tsv' | column -t
Quick Reference - Common Regex Patterns:

Pattern	Meaning	Example
"^prod"	Starts with "prod"	production, prod-api
"staging$"	Ends with "staging"	app-staging, api-staging
"prod|staging"	Contains "prod" OR "staging"	production, staging
"^app-.*-prod$"	Starts with "app-", ends with "-prod"	app-frontend-prod
"test|dev"	Contains "test" OR "dev"	dev-api, test-backend
"^[a-z]+-prod$"	Ends with "-prod", has letters before	frontend-prod, api-prod
Example Usage:

bash
# Get all apps in namespaces starting with "prod"
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace | test("^prod")) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)"' | column -t -s "|"

# Output:
# frontend-app  production  v1.5.2
# api-service   prod-api    v2.1.0
# database      production  v1.0.1
The jq with regex method is the most powerful for complex namespace filtering!
jq not working say nun null
The error means some apps don't have namespace values. Here are working solutions:

Method 1: Handle Null Namespaces Safely

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("prod")) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
Method 2: Filter with Default Value

bash
argocd app list -o json | jq -r '.[] | select((.spec.destination.namespace // "default") | test("prod")) | "\(.metadata.name)|\(.spec.destination.namespace)//"default")|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
Method 3: Debug - See All Namespaces First

bash
# First, see what namespaces exist
argocd app list -o json | jq -r '.[] | "\(.metadata.name): \(.spec.destination.namespace)"'
Method 4: Simple Filter Without jq

bash
# Use grep for simple pattern matching
argocd app list -o json | grep -A 10 -B 5 "prod"
Method 5: Working One-liner with Null Handling

bash
argocd app list -o json | jq -r '
  .[] | 
  .spec.destination.namespace as $ns |
  select($ns != null and ($ns | test("prod"))) |
  "\(.metadata.name)|\($ns)|\(.spec.source.targetRevision)|\(.status.sync.status)"
' | column -t -s "|"
Method 6: Case Insensitive Search

bash
argocd app list -o json | jq -r '
  .[] | 
  select(.spec.destination.namespace != null) |
  select(.spec.destination.namespace | ascii_downcase | test("prod")) |
  "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)"
' | column -t -s "|"
Method 7: See ALL Data First to Debug

bash
# See complete structure of first app
argocd app list -o json | jq '.[0]'

# Or see just namespace fields
argocd app list -o json | jq '.[] | {name: .metadata.name, namespace: .spec.destination.namespace}'
Method 8: Alternative - Filter by App Name Instead

If namespaces are problematic, filter by app name:

bash
argocd app list -o json | jq -r '.[] | select(.metadata.name | test("prod")) | "\(.metadata.name)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
Try This Step-by-Step:

Step 1: First see what data you have:

bash
argocd app list -o json | jq '.[] | {name: .metadata.name, namespace: .spec.destination.namespace}'
Step 2: If you see null namespaces, use this safe filter:

bash
argocd app list -o json | jq -r '
  .[] | 
  select(.spec.destination.namespace != null) | 
  select(.spec.destination.namespace | test("your-pattern")) |
  "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision)"
'
Step 3: If still issues, try cluster-based filtering instead:

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.server | test("prod")) | "\(.metadata.name) | \(.spec.destination.server) | \(.spec.source.targetRevision)"'
Try Method 1 first - it should handle the null namespace issue you're encountering!
step 1 works now what
Great! Now that step 1 works, let's see what namespace patterns you actually have. Based on the output from:

bash
argocd app list -o json | jq '.[] | {name: .metadata.name, namespace: .spec.destination.namespace}'
Choose Your Filter Pattern:

If you see namespaces like:

production, prod, prod-api ‚Üí Use: "prod"
staging, staging-app ‚Üí Use: "staging"
dev, development ‚Üí Use: "dev"
default ‚Üí Use: "default"
Common Patterns to Try:

Filter for production namespaces:

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("prod")) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
Filter for staging namespaces:

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("staging")) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
Filter for specific namespace:

bash
# Exact namespace match (replace "default" with your namespace)
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace == "default") | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | column -t -s "|"
**Or Show Me Your
can I get version of ap also in output
Yes! Here's how to get the app version in the output:

Method 1: Include App Version (Target Revision)

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("prod")) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)|\(.status.health.status)"' | column -t -s "|"
Method 2: With Headers for Clarity

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("prod")) | ["\(.metadata.name)", "\(.spec.destination.namespace)", "\(.spec.source.targetRevision)", "\(.status.sync.status)", "\(.status.health.status)"] | @tsv' | column -t
Method 3: Add Headers Manually

bash
echo -e "APP_NAME\tNAMESPACE\tVERSION\tSYNC_STATUS\tHEALTH_STATUS" && argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test("prod")) | "\(.metadata.name)\t\(.spec.destination.namespace)\t\(.spec.source.targetRevision)\t\(.status.sync.status)\t\(.status.health.status)"' | column -t
Method 4: Clean Formatted Output

bash
argocd app list -o json | jq -r '
  ["APP", "NAMESPACE", "VERSION", "SYNC", "HEALTH"],
  (.[] | 
    select(.spec.destination.namespace != null) | 
    select(.spec.destination.namespace | test("prod")) | 
    [.metadata.name, .spec.destination.namespace, .spec.source.targetRevision, .status.sync.status, .status.health.status]
  ) | @tsv' | column -t
Method 5: Simple One-liner

bash
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace != null) | "\(.metadata.name) | \(.spec.destination.namespace) | \(.spec.source.targetRevision) | \(.status.sync.status)"' | column -t -s "|"
Key Field Explained:

.spec.source.targetRevision = The app version (git tag/branch/commit)
.metadata.name = App name
.spec.destination.namespace = Kubernetes namespace
.status.sync.status = Sync status (Synced/OutOfSync)
.status.health.status = Health status (Healthy/Degraded)
**Example
my version is in images section which get how to treieve
Ah! The version is in the container images. Here's how to retrieve versions from the image tags:

Method 1: Get Versions from Container Images

bash
argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .status.operationState.operation.sync.resources[]? | 
  select(.kind == "Pod" or .kind == "Deployment") | 
  "\($app) | \(.manifest | fromjson?.spec?.template?.spec?.containers[]?.image // "N/A")"'
Method 2: More Robust Image Version Extraction

bash
argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .status.resources[]? | 
  select(.kind == "Pod" or .kind == "Deployment" or .kind == "StatefulSet") |
  (.liveState | fromjson?.spec?.template?.spec?.containers[]?.image) as $image |
  "\($app) | \($image // "N/A")"' | grep -v "N/A"
Method 3: Get Images from Managed Resources

bash
argocd app list -o json | jq -r '.[] | 
  {
    app: .metadata.name,
    namespace: .spec.destination.namespace,
    images: [.status.resources[]? | 
      (.liveState | fromjson?.spec?.template?.spec?.containers[]?.image) // 
      (.liveState | fromjson?.spec?.containers[]?.image)
    ] | unique
  } | "\(.app)|\(.namespace)|\(.images | join(", "))"' | column -t -s "|"
Method 4: Specific Version Extraction with Sync Status

bash
argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .spec.destination.namespace as $ns |
  .status.sync.status as $sync |
  .status.resources[0] as $resource |
  ($resource.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) as $image |
  "\($app)|\($ns)|\($image // "N/A")|\($sync)"' | column -t -s "|"
Method 5: Comprehensive App + Version Report

bash
argocd app list -o json | jq -r '
  ["APP", "NAMESPACE", "IMAGE_VERSION", "SYNC_STATUS"],
  (.[] | 
    .metadata.name as $app |
    .spec.destination.namespace as $ns |
    .status.sync.status as $sync |
    (.status.resources[]? | 
      (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) // 
      (.liveState | fromjson?.spec?.containers[0]?.image)
    ) as $image |
    [$app, $ns, ($image // "N/A"), $sync]
  ) | @tsv' | column -t
Method 6: Extract Version from Image Tag

bash
argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .status.resources[]? | 
  (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) as $image |
  if $image then 
    $image | capture(":(?<version>.*)$") as $version |
    "\($app) | \($version.version // "latest")"
  else
    empty
  end'
Method 7: Simple Working Version

bash
# First, let's see what image data is available
argocd app list -o json | jq '.[0].status.resources[] | {kind: .kind, image: (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image)}'
Method 8: Most Reliable Approach

bash
argocd app get <APP-NAME> -o json | jq '.status.resources[] | select(.kind == "Deployment") | .liveState | fromjson | .spec.template.spec.containers[0].image'
Quick Test - Check One App First:

bash
# Test with one app to see the structure
argocd app get <your-app-name> -o json | jq '.status.resources[] | {kind: .kind, image: (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image)}'
If Images Aren't in status.resources:

bash
# Get the manifest to see where images are defined
argocd app get <your-app-name> -o json | jq '.status.operationState.operation.sync.resources[] | select(.kind == "Deployment") | .manifest | fromjson | .spec.template.spec.containers[0].image'
Try Method 3 first - it's the most comprehensive for extracting image versions from all container resources!
quote windows issue
Here are the solutions for Windows quote issues:

Method 1: Use PowerShell Instead of CMD

powershell
argocd app list -o json | jq -r '.[] | select(.spec.destination.namespace -ne $null) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)"' | ConvertFrom-Csv -Delimiter "|" -Header "App","Namespace","Version","Status" | Format-Table
Method 2: Windows CMD with Careful Quoting

cmd
argocd app list -o json | jq -r ".[] | select(.spec.destination.namespace != null) | \"\\(.metadata.name)|\\(.spec.destination.namespace)|\\(.spec.source.targetRevision)|\\(.status.sync.status)\"" | column -t -s "|"
Method 3: Save to File First

cmd
# Step 1: Save JSON to file
argocd app list -
I ned git bash script
Here's a Git Bash script to get ArgoCD apps with versions:

Script 1: Basic App Version List

bash
#!/bin/bash

# Get ArgoCD apps with versions and sync status
argocd app list -o json | jq -r '.[] | 
  "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)|\(.status.health.status)"' | 
  column -t -s "|"
Script 2: With Headers

bash
#!/bin/bash

echo "APP|NAMESPACE|VERSION|SYNC_STATUS|HEALTH" | column -t -s "|"
argocd app list -o json | jq -r '.[] | 
  "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.status.sync.status)|\(.status.health.status)"' | 
  column -t -s "|"
Script 3: Filter by Namespace Pattern

bash
#!/bin/bash

PATTERN="${1:-prod}"  # Default pattern is "prod"

echo "Filtering namespaces with pattern: $PATTERN"
echo "APP|NAMESPACE|VERSION|SYNC_STATUS|HEALTH" | column -t -s "|"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | 
  select(.spec.destination.n
with container image as it has my version
Here's a Git Bash script to get ArgoCD apps with container image versions:

Script 1: Basic Container Image Versions

bash
#!/bin/bash

echo "Extracting ArgoCD app container image versions..."
echo ""

argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .spec.destination.namespace as $ns |
  .status.sync.status as $sync |
  .status.health.status as $health |
  .status.resources[]? | 
  (.liveState | fromjson?.spec?.template?.spec?.containers[]?.image) as $image |
  if $image then "\($app)|\($ns)|\($image)|\($sync)|\($health)" else empty end' | 
  column -t -s "|"
Script 2: With Headers and Unique Results

bash
#!/bin/bash

echo "APP|NAMESPACE|CONTAINER_IMAGE|SYNC_STATUS|HEALTH" | column -t -s "|"
echo "----------------------------------------------------------------"

argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .spec.destination.namespace as $ns |
  .status.sync.status as $sync |
  .status.health.status as $health |
  [.status.resources[]? | 
    (.liveState | fromjson?.spec?.template?.spec?.containers[]?.image) // 
    (.liveState | fromjson?.spec?.containers[]?.image)
  ] | unique[] | 
  "\($app)|\($ns)|\(.)|\($sync)|\($health)"' | 
  column -t -s "|"
Script 3: Extract Just Version from Image Tag

bash
#!/bin/bash

echo "APP|NAMESPACE|VERSION|SYNC_STATUS|HEALTH" | column -t -s "|"
echo "---------------------------------------------------"

argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .spec.destination.namespace as $ns |
  .status.sync.status as $sync |
  .status.health.status as $health |
  .status.resources[]? | 
  (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) as $image |
  if $image then 
    ($image | split(":")[1]) as $version |
    "\($app)|\($ns)|\($version // "latest")|\($sync)|\($health)"
  else 
    empty 
  end' | 
  column -t -s "|"
Script 4: Comprehensive Image Report

bash
#!/bin/bash

echo "ARGOCD CONTAINER IMAGE VERSION REPORT"
echo "======================================"
date
echo ""

argocd app list -o json | jq -r '
  ["APP", "NAMESPACE", "IMAGE", "VERSION", "SYNC", "HEALTH"],
  (.[] | 
    .metadata.name as $app |
    .spec.destination.namespace as $ns |
    .status.sync.status as $sync |
    .status.health.status as $health |
    .status.resources[]? | 
    (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) as $image |
    if $image then
      ($image | split(":")[1]) as $version |
      [$app, $ns, ($image | split(":")[0]), ($version // "latest"), $sync, $health]
    else
      empty
    end
  ) | @tsv' | 
  column -t
Script 5: Save to File with Timestamp

bash
#!/bin/bash

OUTPUT_FILE="argocd_versions_$(date +%Y%m%d_%H%M%S).txt"

echo "Generating ArgoCD version report to $OUTPUT_FILE..."

{
  echo "ARGOCD APPLICATION VERSION REPORT"
  echo "Generated: $(date)"
  echo "================================================"
  echo ""
  
  argocd app list -o json | jq -r '.[] | 
    .metadata.name as $app |
    .spec.destination.namespace as $ns |
    .status.sync.status as $sync |
    .status.health.status as $health |
    .status.resources[]? | 
    select(.kind == "Deployment" or .kind == "StatefulSet") |
    (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) as $image |
    if $image then 
      "App: \($app)"
      "Namespace: \($ns)"
      "Image: \($image)"
      "Status: \($sync) | \($health)"
      "----------------------------------------"
    else 
      empty 
    end'
} > "$OUTPUT_FILE"

echo "Report saved to: $OUTPUT_FILE"
cat "$OUTPUT_FILE"
Script 6: Simple One-liner for Quick Check

bash
#!/bin/bash

# Quick image version check
argocd app list -o json | jq -r '.[] | "\(.metadata.name): \(.status.resources[0].liveState | fromjson?.spec?.template?.spec?.containers[0]?.image // "No image found")"'
How to Use:

Save any script as argocd-versions.sh
Make it executable:

bash
chmod +x argocd-versions.sh
Run it:

bash
./argocd-versions.sh
Example Output:

text
APP               NAMESPACE  CONTAINER_IMAGE                    VERSION  SYNC      HEALTH
frontend-prod     production myrepo/frontend:1.5.2             1.5.2    Synced    Healthy
api-staging       staging    myrepo/api:2.1.0-rc1              2.1.0-rc1 OutOfSync Healthy
db-production     production postgres:15.3                     15.3     Synced    Healthy
Try Script 2 first - it gives the most comprehensive view with container images!
test one app first simple script to get image
Here's a simple script to test getting the image for one app first:

Script 1: Test Single App Image

bash
#!/bin/bash

# Test one app to see image structure
APP_NAME="your-app-name"  # Replace with your actual app name

echo "Testing image extraction for app: $APP_NAME"
echo "==========================================="

argocd app get "$APP_NAME" -o json | jq '.status.resources[] | {kind: .kind, image: (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image)}'
Script 2: Simple One-App Version

bash
#!/bin/bash

APP_NAME="your-app-name"  # Change this!

echo "App: $APP_NAME"
echo "Container Images:"

argocd app get "$APP_NAME" -o json | jq -r '.status.resources[] | 
  .kind as $kind |
  (.liveState | fromjson?.spec?.template?.spec?.containers[]?.image) as $image |
  if $image then "  \($kind): \($image)" else empty end'
Script 3: Get All Images for One App

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Application: $APP_NAME"
echo "================================"

argocd app get "$APP_NAME" -o json | jq -r '
  .metadata.name as $app |
  .status.resources[]? | 
  .kind as $kind |
  (.liveState | fromjson?.spec?.template?.spec?.containers[]?.image) as $image |
  if $image then 
    "\($kind): \($image)" 
  else 
    "\($kind): No image found" 
  end'
Script 4: Quick Test Command

bash
#!/bin/bash

# Just replace "your-app-name" and run
argocd app get "your-app-name" -o json | jq -r '.status.resources[0].liveState | fromjson | .spec.template.spec.containers[0].image'
How to Use:

Replace your-app-name with your actual ArgoCD app name
Save as test-app-image.sh
Make executable and run:

bash
chmod +x test-app-image.sh
./test-app-image.sh
Example:

bash
#!/bin/bash
APP_NAME="frontend-production"

echo "Testing: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq '.status.resources[] | {kind: .kind, image: (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image)}'
Expected Output:

json
{
  "kind": "Deployment",
  "image": "myrepo/frontend:1.5.2"
}
{
  "kind": "Service",
  "image": null
}
Run Script 1 first to see what image data is available for your app!
git bash in windows box , getting windows cmd shell quoting issue
Here are Git Bash scripts that avoid Windows quoting issues:

Script 1: Simple Single App Test

bash
#!/bin/bash

# Set app name here
APP_NAME="your-app-name"

echo "Testing image for: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq '.status.resources[0].liveState' | jq '.spec.template.spec.containers[0].image'
Script 2: Save JSON to File First

bash
#!/bin/bash

APP_NAME="your-app-name"
TEMP_FILE="temp_app.json"

echo "Getting data for: $APP_NAME"
argocd app get "$APP_NAME" -o json > "$TEMP_FILE"

echo "Container images:"
jq -r '.status.resources[] | select(.liveState != null) | .liveState | fromjson | .spec.template.spec.containers[0]?.image // empty' "$TEMP_FILE"

# Clean up
rm "$TEMP_FILE"
Script 3: Step-by-Step Approach

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "=== Step 1: Get App JSON ==="
argocd app get "$APP_NAME" -o json > app_data.json

echo "=== Step 2: Extract Images ==="
jq -r '.status.resources[] | 
  "Kind: \(.kind), Image: \(.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image // "not found")"' app_data.json

echo "=== Step 3: Cleanup ==="
rm app_data.json
Script 4: Simple Image Extraction

bash
#!/bin/bash

APP_NAME="your-app-name"
JSON_FILE="temp.json"

# Get data and save to file
argocd app get "$APP_NAME" -o json > "$JSON_FILE"

# Process the file
echo "Images for $APP_NAME:"
jq -r '.status.resources[] | 
  .kind as $k | 
  (.liveState | fromjson?.spec?.template?.spec?.containers[0]?.image) as $img | 
  if $img then "\($k): \($img)" else empty end' "$JSON_FILE"

rm "$JSON_FILE"
Script 5: One-liner with File

bash
#!/bin/bash

APP_NAME="your-app-name"
argocd app get "$APP_NAME" -o json > temp.json && jq -r '.status.resources[0].liveState | fromjson | .spec.template.spec.containers[0].image' temp.json && rm temp.json
How to Use:

Create a new file test-app.sh
Copy any script above into the file
Replace your-app-name with your actual app name
Run in Git Bash:

bash
chmod +x test-app.sh
./test-app.sh
Alternative: Direct Commands in Git Bash

bash
# Command 1: Simple test
APP="your-app-name"
argocd app get $APP -o json | jq '.status.resources[0].liveState' | jq '.spec.template.spec.containers[0].image'

# Command 2: With temp file
argocd app get your-app-name -o json > t.json
jq -r '.status.resources[0].liveState | fromjson | .spec.template.spec.containers[0].image' t.json
rm t.json
Troubleshooting Tips:

If you still get issues, try:

bash
# Use jq from file only
argocd app get your-app-name -o json > data.json
jq '.' data.json | head -20  # Check if JSON is valid
jq '.status.resources[0]' data.json  # Check first resource
The file-based approach (Script 2) is most reliable in Windows Git Bash!
status.resources give permission denied
The status.resources requires additional permissions. Here are alternative approaches that should work:

Script 1: Use manifest instead of status.resources

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Getting image from manifest for: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq -r '.status.operationState.operation.sync.resources[] | select(.kind == "Deployment") | .manifest | fromjson | .spec.template.spec.containers[0].image'
Script 2: Get from source manifests

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Getting source manifest for: $APP_NAME"
argocd app manifests "$APP_NAME" | grep -A 5 -B 5 "image:"
Script 3: Use kubectl through ArgoCD

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Getting deployed resources for: $APP_NAME"
argocd app resources "$APP_NAME" | grep -i deployment
Script 4: Get from sync operation

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Checking sync operation for: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq -r '.status.operationState.syncResult.resources[] | .name + ": " + (.targetState | fromjson | .spec.template.spec.containers[0].image // "no image")'
Script 5: Simple app details

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Basic app info for: $APP_NAME"
argocd app get "$APP_NAME" -o wide
Script 6: Get source revision and infer version

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "App: $APP_NAME"
echo "Source Revision: $(argocd app get "$APP_NAME" -o json | jq -r '.spec.source.targetRevision')"
echo "Repo: $(argocd app get "$APP_NAME" -o json | jq -r '.spec.source.repoURL')"
echo "Path: $(argocd app get "$APP_NAME" -o json | jq -r '.spec.source.path')"
Script 7: Use argocd app manifests

bash
#!/bin/bash

APP_NAME="your-app-name"
TEMP_FILE="manifests.yaml"

echo "Exporting manifests for: $APP_NAME"
argocd app manifests "$APP_NAME" > "$TEMP_FILE"

echo "Container images found:"
grep "image:" "$TEMP_FILE" | head -10

rm "$TEMP_FILE"
How to Use:

Replace your-app-name with your actual app name
Try Script 1 first - it uses operationState which usually has better access
If that fails, try Script 2 - uses argocd app manifests command
Quick Test Commands:

bash
# Test 1: Basic app info
argocd app get your-app-name -o wide

# Test 2: Get manifests
argocd app manifests your-app-name | head -20

# Test 3: Check what data is available
argocd app get your-app-name -o json | jq '.status | keys'
Start with Script 1 - the operationState path usually works without permission issues!
my version  is in summary page of app in image field
Ah! You're seeing the image version in the ArgoCD UI summary page. Here's how to get that same information via CLI:

Script 1: Get Image from Summary (using resources tree)

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Getting images from summary for: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq -r '.status.summary.images[]'
Script 2: Simple One-liner

bash
#!/bin/bash

APP_NAME="your-app-name"
argocd app get "$APP_NAME" -o json | jq -r '.status.summary.images[]'
Script 3: With App Context

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "=== Image Versions for $APP_NAME ==="
argocd app get "$APP_NAME" -o json | jq -r '
  .metadata.name as $app |
  .status.summary.images[] as $image |
  "\($app): \($image)"'
Script 4: Multiple Apps with Images

bash
#!/bin/bash

echo "APP|IMAGES" | column -t -s "|"
echo "-------------------"

argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  (.status.summary.images | join(", ")) as $images |
  "\($app)|\($images)"' | column -t -s "|"
Script 5: Complete Version Report

bash
#!/bin/bash

echo "ARGOCD APPLICATION IMAGE VERSIONS"
echo "=================================="
date
echo ""

argocd app list -o json | jq -r '.[] | 
  "Application: \(.metadata.name)
Namespace: \(.spec.destination.namespace)
Sync: \(.status.sync.status) | Health: \(.status.health.status)
Images: \(.status.summary.images // ["None"] | join(", "))
----------------------------------------"'
How to Use:

Replace your-app-name with your actual app name
Save as get-images.sh
Run in Git Bash:

bash
chmod +x get-images.sh
./get-images.sh
Quick Test:

bash
# Just replace your app name and run this directly in Git Bash
argocd app get "your-app-name" -o json | jq -r '.status.summary.images[]'
Expected Output:

text
myregistry.com/app-frontend:v1.5.2
myregistry.com/app-backend:v2.1.0
postgres:15.3
If you want to extract just version tags:

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Version tags for: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq -r '.status.summary.images[] | split(":")[1]'
Try Script 1 first - this should give you exactly what you see in the UI summary page!
status field gives perm denied
If even the status field gives permission denied, let's use approaches that don't require status access:

Script 1: Use Source Information Only

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "App: $APP_NAME"
echo "Source Revision: $(argocd app get "$APP_NAME" -o json | jq -r '.spec.source.targetRevision')"
echo "Path: $(argocd app get "$APP_NAME" -o json | jq -r '.spec.source.path')"
echo "Repo: $(argocd app get "$APP_NAME" -o json | jq -r '.spec.source.repoURL')"
Script 2: Basic App List with Source Info

bash
#!/bin/bash

echo "APP|NAMESPACE|SOURCE_REVISION|REPO" | column -t -s "|"
echo "----------------------------------------"

argocd app list -o json | jq -r '.[] | 
  "\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.source.targetRevision)|\(.spec.source.repoURL)"' | 
  column -t -s "|"
Script 3: Get App Sync Operation Data

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Sync operation for: $APP_NAME"
argocd app get "$APP_NAME" --refresh
argocd app sync "$APP_NAME" --dry-run
Script 4: Use argocd app manifests

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Getting manifests for: $APP_NAME"
argocd app manifests "$APP_NAME" | grep -i "image:" | head -10
Script 5: Export and Parse Manifests

bash
#!/bin/bash

APP_NAME="your-app-name"
TEMP_FILE="manifests.yaml"

echo "Exporting and parsing manifests for: $APP_NAME"
argocd app manifests "$APP_NAME" > "$TEMP_FILE"

echo "Found container images:"
grep -A 2 -B 2 "image:" "$TEMP_FILE" | grep -v "^--$"

rm "$TEMP_FILE"
Script 6: Simple Wide Format

bash
#!/bin/bash

echo "Using wide format (no JSON parsing):"
argocd app list -o wide
Script 7: Get App Source Details

bash
#!/bin/bash

APP_NAME="your-app-name"

argocd app get "$APP_NAME" -o json | jq '.spec.source'
How to Use:

Try Script 6 first - argocd app list -o wide shows most info without permissions
If that works, try Script 4 - argocd app manifests gets the actual deployed manifests
Script 1 gives you source control version info
Quick Commands to Test:

bash
# Test 1: Basic wide format
argocd app list -o wide

# Test 2: Get app source info  
argocd app get your-app-name -o json | jq '.spec'

# Test 3: Export manifests
argocd app manifests your-app-name | head -30
Start with Script 6 - the wide format usually works even with restricted permissions!
can I get full json and then see if versions of image is in there as my versions is in pod container image
Yes! Let's get the full JSON and search for the image versions. Here are the scripts:

Script 1: Get Full JSON and Search for Images

bash
#!/bin/bash

APP_NAME="your-app-name"
JSON_FILE="full_app.json"

echo "Getting full JSON for: $APP_NAME"
argocd app get "$APP_NAME" -o json > "$JSON_FILE"

echo "=== Searching for image fields ==="
grep -i "image" "$JSON_FILE"

echo ""
echo "=== Full JSON saved to: $JSON_FILE ==="
echo "You can now examine the file for image versions"
Script 2: Extract All Image-like Fields

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Extracting all image-related fields for: $APP_NAME"
argocd app get "$APP_NAME" -o json | jq '.. | .image? // empty' | grep -v null
Script 3: Deep Search for Container Images

bash
#!/bin/bash

APP_NAME="your-app-name"
JSON_FILE="app_data.json"

echo "Deep searching for container images in: $APP_NAME"
argocd app get "$APP_NAME" -o json > "$JSON_FILE"

echo "=== Possible image locations ==="
jq -r 'paths | join(".")' "$JSON_FILE" | grep -i image
Script 4: Get JSON and Find Image Patterns

bash
#!/bin/bash

APP_NAME="your-app-name"
JSON_FILE="app_full.json"

echo "Saving full JSON to: $JSON_FILE"
argocd app get "$APP_NAME" -o json > "$JSON_FILE"

echo ""
echo "=== Image patterns found ==="
grep -E '("image":|image:)' "$JSON_FILE" | head -20

echo ""
echo "Now check the file: $JSON_FILE for pod container images"
Script 5: Simple JSON Dump

bash
#!/bin/bash

APP_NAME="your-app-name"

echo "Full JSON output for: $APP_NAME"
argocd app get "$APP_NAME" -o json
Script 6: Search in Specific Sections

bash
#!/bin/bash

APP_NAME="your-app-name"
JSON_FILE="app.json"

argocd app get "$APP_NAME" -o json > "$JSON_FILE"

echo "=== Checking operationState ==="
jq '.status.operationState' "$JSON_FILE" | grep -i image

echo "=== Checking syncResult ==="  
jq '.status.operationState.syncResult' "$JSON_FILE" | grep -i image

echo "=== Checking resources ==="
jq '.status.resources' "$JSON_FILE" | grep -i image
How to Use:

Replace your-app-name with your actual app name
Run Script 1 or 4 first to save the full JSON
Then manually search the generated JSON file for image fields
Quick Commands:

bash
# Save full JSON to file
argocd app get your-app-name -o json > full_output.json

# Search for images in the file
grep -i "image" full_output.json

# Or view the entire file
cat full_output.json
What to Look For:

In the JSON file, search for:

"image":
"Image":
Container image URLs like nginx:1.2.3
Your container registry URLs
Run Script 4 first - it will save the full JSON and show you where the images might be located!
ok summary working now and images I can get ,can I get full script one line o get app name namespace sync status and version now form images 1
Yes! Here's a one-liner script to get app name, namespace, sync status, and image versions:

One-liner Script:

bash
#!/bin/bash

argocd app list -o json | jq -r '.[] | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

echo "APP|NAMESPACE|SYNC_STATUS|IMAGES" | column -t -s "|" && argocd app list -o json | jq -r '.[] | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
Clean Version with Filtered Output:

bash
#!/bin/bash

argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .spec.destination.namespace as $ns |
  .status.sync.status as $sync |
  (.status.summary.images // ["No images"]) as $images |
  "\($app)|\($ns)|\($sync)|\($images | join(", "))"' | 
  column -t -s "|"
Save as get-app-versions.sh and run:

bash
chmod +x get-app-versions.sh
./get-app-versions.sh
Expected Output:

text
APP-NAME          NAMESPACE   SYNC_STATUS  IMAGES
frontend-prod     production  Synced       nginx:1.25,app-frontend:v1.5.2
api-staging       staging     OutOfSync    app-api:v2.1.0,redis:7.0
db-production     production  Synced       postgres:15.3
This one-liner gives you exactly what you need: app name, namespace, sync status, and container image versions!
I need namespace filter
Here's the one-liner with namespace filter:

One-liner with Namespace Filter:

bash
#!/bin/bash

PATTERN="${1:-.*}"  # Default to all namespaces if no pattern provided

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|IMAGES" | column -t -s "|" && argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
Usage Examples:

bash
# Show all namespaces (default)
./script.sh

# Show only production namespaces
./script.sh "prod"

# Show namespaces starting with "app-"
./script.sh "^app-"

# Show namespaces ending with "-prod"  
./script.sh "-prod$"

# Show namespaces containing "staging"
./script.sh "staging"
Common Patterns:

bash
# Production namespaces
./script.sh "prod"

# Staging namespaces  
./script.sh "staging"

# Development namespaces
./script.sh "dev"

# Specific namespace
./script.sh "^default$"

# Multiple patterns (prod OR staging)
./script.sh "prod|staging"
Save as get-apps-by-ns.sh:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "Filtering namespaces with pattern: '$PATTERN'"
echo ""

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
Run it: ./get-apps-by-ns.sh "prod"

Now you can filter by any namespace pattern!
list all json so not working
Here's the script that lists all JSON first to debug:

Script 1: Debug - Show All JSON Structure

bash
#!/bin/bash

echo "=== FULL JSON OUTPUT ==="
argocd app list -o json
Script 2: Show App Names and Namespaces Only

bash
#!/bin/bash

echo "=== APPS AND NAMESPACES ==="
argocd app list -o json | jq -r '.[] | "\(.metadata.name) -> \(.spec.destination.namespace)"'
Script 3: Check if summary.images exists

bash
#!/bin/bash

echo "=== CHECKING SUMMARY.IMAGES FIELD ==="
argocd app list -o json | jq -r '.[0] | has("status") and (.status | has("summary")) and (.status.summary | has("images"))'
Script 4: See What Fields Are Available

bash
#!/bin/bash

echo "=== AVAILABLE FIELDS IN FIRST APP ==="
argocd app list -o json | jq '.[0] | {
  name: .metadata.name,
  namespace: .spec.destination.namespace,
  syncStatus: .status.sync.status,
  hasSummary: (.status | has("summary")),
  summaryKeys: (.status.summary | keys),
  hasImages: (.status.summary | has("images"))
}'
Script 5: Alternative - Get Images from Different Field

bash
#!/bin/bash

echo "=== TRYING DIFFERENT IMAGE LOCATIONS ==="
argocd app list -o json | jq -r '.[] | 
  .metadata.name as $app |
  .spec.destination.namespace as $ns |
  .status.sync.status as $sync |
  "\($app)|\($ns)|\($sync)|\(.status.summary.images // .status.images // ["N/A"] | join(","))"' | 
  column -t -s "|"
Run these to debug:

First run Script 1 to see the full JSON structure
Then run Script 4 to see what fields are available
Then run Script 2 to verify namespaces exist
If summary.images doesn't exist, try this working version:

bash
#!/bin/bash

PATTERN="${1:-.*}"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | 
  select(.spec.destination.namespace | test($pattern)) | 
  "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.spec.source.targetRevision)"' | 
  column -t -s "|"
Run the debug scripts first to see what data is actually available in your ArgoCD setup!
image from summary works but your script wil namespace filter does not
Here's the fixed script with namespace filter that works with images from summary:

Working Script with Namespace Filter:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|IMAGES" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
Safe Version (Handles Null Namespaces):

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "Filtering namespaces with pattern: '$PATTERN'"
echo "APP|NAMESPACE|SYNC_STATUS|IMAGES" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace? != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | join(","))"' | column -t -s "|"
Usage:

bash
# All namespaces
./script.sh

# Production namespaces
./script.sh "prod"

# Specific namespace
./script.sh "^default$"

# Namespaces containing "staging"
./script.sh "staging"
The key fix is select(.spec.destination.namespace != null) before the regex test!
images has full ear path ..I only need last field version last token :
Here's the script to extract only the version (last token after colon) from the image paths:

Script to Extract Version Only:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | map(split(":")[1] // "latest") | join(","))"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSIONS" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | map(split(":")[1] // "latest") | join(","))"' | column -t -s "|"
Example Transformation:

registry.company.com/app/frontend:v1.5.2 ‚Üí v1.5.2
nginx:1.25.3 ‚Üí 1.25.3
postgres:15 ‚Üí 15
redis:latest ‚Üí latest
If you want only unique versions per app:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSIONS" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | map(split(":")[1] // "latest") | unique | join(","))"' | column -t -s "|"
Usage:

bash
# All namespaces with versions only
./script.sh

# Production namespaces with versions
./script.sh "prod"
Now you'll get only the version tags instead of full image paths!
how to use split directly n. summary image [1] field
Here's how to use split directly on the summary.images field:

Script with Direct Split:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | map(split(":")[1]) | join(","))"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSIONS" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | map(split(":")[1]) | join(","))"' | column -t -s "|"
Safe Version (Handles images without colon):

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSIONS" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images // ["N/A"] | map(if contains(":") then split(":")[1] else . end) | join(","))"' | column -t -s "|"
Alternative - Extract Version Only:

bash
#!/bin/bash

PATTERN="${1:-.*}"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | .status.summary.images[]? | split(":")[1]'
The key part is: map(split(":")[1]) which:

Takes each image string from the array
Splits on :
Takes the second element [1] (the version)
Maps over all images in the array
Now you'll get only the version numbers!
I know summary image [1] has the value
Perfect! If you know summary.images[1] has the version value, here's the script:

Script Using summary.images[1] Directly:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1] // "N/A")"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSION" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1] // "N/A")"' | column -t -s "|"
If you want the first image instead of second:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSION" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[0] // "N/A")"' | column -t -s "|"
Usage:

bash
# All namespaces
./script.sh

# Production namespaces
./script.sh "prod"

# Staging namespaces
./script.sh "staging"
Now it directly uses summary.images[1] to get the version value!
now need positsplit last field index :on image field
Here's the script to split on colon and get the last field (version) from the image:

Script with Last Field After Split:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1] // "N/A" | split(":")[-1])"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSION" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1] // "N/A" | split(":")[-1])"' | column -t -s "|"
Safe Version (Handles Missing Images):

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSION" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1]? // "N/A" | if . != "N/A" then split(":")[-1] else "N/A" end)"' | column -t -s "|"
Example Transformation:

registry.company.com/app/frontend:v1.5.2 ‚Üí v1.5.2
nginx:1.25.3 ‚Üí 1.25.3
postgres:15 ‚Üí 15
redis:latest ‚Üí latest
The key is split(":")[-1] which splits on colon
whats N/A for
N/A is for handling cases where the data is missing or null. Here's the script without N/A:

Script Without N/A:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1]? | split(":")[-1])"' | column -t -s "|"
With Headers:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSION" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1]? | split(":")[-1])"' | column -t -s "|"
Even Cleaner - Skip Apps Without Images:

bash
#!/bin/bash

PATTERN="${1:-.*}"
echo "APP|NAMESPACE|SYNC_STATUS|VERSION" | column -t -s "|"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | select(.status.summary.images[1]?) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1] | split(":")[-1])"' | column -t -s "|"
Now it will just show empty for missing images instead of N/A!
windows git bash will it work
Yes, it will work in Windows Git Bash! Here's the Windows-compatible version:

Windows Git Bash Compatible Script:

bash
#!/bin/bash

PATTERN="${1:-.*}"

argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1]? | split(":")[-1])"' | column -t -s "|"
Save as get-versions.sh and run:

bash
# Make executable
chmod +x get-versions.sh

# Run with namespace filter
./get-versions.sh "prod"
If you get column command issues, use this version without column:

bash
#!/bin/bash

PATTERN="${1:-.*}"

echo "APP|NAMESPACE|SYNC_STATUS|VERSION"
argocd app list -o json | jq -r --arg pattern "$PATTERN" '.[] | select(.spec.destination.namespace != null) | select(.spec.destination.namespace | test($pattern)) | "\(.metadata.name)|\(.spec.destination.namespace)|\(.status.sync.status)|\(.status.summary.images[1]? | split(":")[-1])"' | sed 's/|/\t/g'
